// This file is automatically generated from CSSProperties.json by the process-css-properties.py script. Do not edit it.

#include "config.h"
#include "CSSPropertyParsing.h"

#include "CSSFunctionValue.h"
#include "CSSParserContext.h"
#include "CSSParserIdioms.h"
#include "CSSPropertyParser.h"
#include "CSSPropertyParserConsumer+Align.h"
#include "CSSPropertyParserConsumer+Anchor.h"
#include "CSSPropertyParserConsumer+AngleDefinitions.h"
#include "CSSPropertyParserConsumer+Animations.h"
#include "CSSPropertyParserConsumer+AppleVisualEffect.h"
#include "CSSPropertyParserConsumer+Attr.h"
#include "CSSPropertyParserConsumer+Background.h"
#include "CSSPropertyParserConsumer+Box.h"
#include "CSSPropertyParserConsumer+CSSPrimitiveValueResolver.h"
#include "CSSPropertyParserConsumer+Color.h"
#include "CSSPropertyParserConsumer+ColorAdjust.h"
#include "CSSPropertyParserConsumer+Contain.h"
#include "CSSPropertyParserConsumer+Content.h"
#include "CSSPropertyParserConsumer+CounterStyles.h"
#include "CSSPropertyParserConsumer+Display.h"
#include "CSSPropertyParserConsumer+Easing.h"
#include "CSSPropertyParserConsumer+Filter.h"
#include "CSSPropertyParserConsumer+Font.h"
#include "CSSPropertyParserConsumer+Grid.h"
#include "CSSPropertyParserConsumer+Ident.h"
#include "CSSPropertyParserConsumer+Image.h"
#include "CSSPropertyParserConsumer+Inline.h"
#include "CSSPropertyParserConsumer+Inset.h"
#include "CSSPropertyParserConsumer+IntegerDefinitions.h"
#include "CSSPropertyParserConsumer+LengthDefinitions.h"
#include "CSSPropertyParserConsumer+LengthPercentageDefinitions.h"
#include "CSSPropertyParserConsumer+List.h"
#include "CSSPropertyParserConsumer+Lists.h"
#include "CSSPropertyParserConsumer+Masking.h"
#include "CSSPropertyParserConsumer+Motion.h"
#include "CSSPropertyParserConsumer+NumberDefinitions.h"
#include "CSSPropertyParserConsumer+Overflow.h"
#include "CSSPropertyParserConsumer+Page.h"
#include "CSSPropertyParserConsumer+PercentageDefinitions.h"
#include "CSSPropertyParserConsumer+PointerEvents.h"
#include "CSSPropertyParserConsumer+Position.h"
#include "CSSPropertyParserConsumer+PositionTry.h"
#include "CSSPropertyParserConsumer+Primitives.h"
#include "CSSPropertyParserConsumer+ResolutionDefinitions.h"
#include "CSSPropertyParserConsumer+Ruby.h"
#include "CSSPropertyParserConsumer+SVG.h"
#include "CSSPropertyParserConsumer+ScrollSnap.h"
#include "CSSPropertyParserConsumer+Scrollbars.h"
#include "CSSPropertyParserConsumer+Shapes.h"
#include "CSSPropertyParserConsumer+Sizing.h"
#include "CSSPropertyParserConsumer+Speech.h"
#include "CSSPropertyParserConsumer+String.h"
#include "CSSPropertyParserConsumer+Syntax.h"
#include "CSSPropertyParserConsumer+Text.h"
#include "CSSPropertyParserConsumer+TextDecoration.h"
#include "CSSPropertyParserConsumer+TimeDefinitions.h"
#include "CSSPropertyParserConsumer+Timeline.h"
#include "CSSPropertyParserConsumer+Transform.h"
#include "CSSPropertyParserConsumer+Transitions.h"
#include "CSSPropertyParserConsumer+UI.h"
#include "CSSPropertyParserConsumer+URL.h"
#include "CSSPropertyParserConsumer+ViewTransition.h"
#include "CSSPropertyParserConsumer+WillChange.h"
#include "CSSValuePool.h"
#include "DeprecatedGlobalSettings.h"

namespace WebCore {

using namespace CSSPropertyParserHelpers;

static bool isKeywordValidForTestUsingSharedRule(CSSValueID keyword)
{
    switch (keyword) {
    case CSSValueID::CSSValueAuto:
        return true;
    default:
        return false;
    }
}

static RefPtr<CSSValue> consumeTestNumericValueRange(CSSParserTokenRange& range, const CSSParserContext& context)
{
    if (auto result = CSSPrimitiveValueResolver<CSS::Number<CSS::Range{-CSS::Range::infinity, -10}>>::consumeAndResolve(range, context, { .parserMode = context.mode }))
        return result;
    if (auto result = CSSPrimitiveValueResolver<CSS::Length<CSS::Range{0, CSS::Range::infinity}>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Allow }))
        return result;
    if (auto result = CSSPrimitiveValueResolver<CSS::Angle<CSS::Range{-90, 90}>>::consumeAndResolve(range, context, { .parserMode = context.mode, .unitless = UnitlessQuirk::Forbid, .unitlessZero = UnitlessZeroQuirk::Forbid }))
        return result;
    return CSSPrimitiveValueResolver<CSS::Percentage<CSS::Range{1, 100}>>::consumeAndResolve(range, context, { .parserMode = context.mode });
}

static RefPtr<CSSValue> consumeTestUsingSharedRule(CSSParserTokenRange& range, const CSSParserContext& context)
{
    if (auto result = consumeIdent(range, isKeywordValidForTestUsingSharedRule))
        return result;
    if (auto result = CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode }))
        return result;
    return CSSPrimitiveValueResolver<CSS::Percentage<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
}

RefPtr<CSSValue> CSSPropertyParsing::parseStyleProperty(CSSParserTokenRange& range, CSSPropertyID id, CSSPropertyID currentShorthand, const CSSParserContext& context)
{
    if (!isExposed(id, context.propertySettings) && !isInternal(id)) {
        // Allow internal properties as we use them to parse several internal-only-shorthands (e.g. background-repeat),
        // and to handle certain DOM-exposed values (e.g. -webkit-font-size-delta from execCommand('FontSizeDelta')).
        ASSERT_NOT_REACHED();
        return nullptr;
    }
    switch (id) {
    case CSSPropertyID::CSSPropertyTestTopPriority:
    case CSSPropertyID::CSSPropertyTestHighPriority:
    case CSSPropertyID::CSSPropertyTestAnimationWrapper:
    case CSSPropertyID::CSSPropertyTestAnimationWrapperAccelerationAlways:
    case CSSPropertyID::CSSPropertyTestAnimationWrapperAccelerationThreadedOnly:
    case CSSPropertyID::CSSPropertyTestProperty:
    case CSSPropertyID::CSSPropertyTestSettingsOne:
    case CSSPropertyID::CSSPropertyTestSinkPriority:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalBlock:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupLogicalInline:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalHorizontal:
    case CSSPropertyID::CSSPropertyTestLogicalPropertyGroupPhysicalVertical:
        return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
    case CSSPropertyID::CSSPropertyTestNumericValueRange:
        return consumeTestNumericValueRange(range, context);
    case CSSPropertyID::CSSPropertyTestUsingSharedRule:
        return consumeTestUsingSharedRule(range, context);
    default:
        return nullptr;
    }
}

bool CSSPropertyParsing::isKeywordValidForStyleProperty(CSSPropertyID id, CSSValueID keyword, const CSSParserContext&)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyTestUsingSharedRule:
        return isKeywordValidForTestUsingSharedRule(keyword);
    default:
        return false;
    }
}

bool CSSPropertyParsing::isKeywordFastPathEligibleStyleProperty(CSSPropertyID id)
{
    switch (id) {
    case CSSPropertyID::CSSPropertyTestUsingSharedRule:
        return true;
    default:
        return false;
    }
}

RefPtr<CSSValue> CSSPropertyParsing::parseFirstAtRuleDescriptor(CSSParserTokenRange& range, CSSPropertyID id, const CSSParserContext& context)
{
    if (!isExposed(id, context.propertySettings) && !isInternal(id)) {
        // Allow internal properties as we use them to parse several internal-only-shorthands (e.g. background-repeat),
        // and to handle certain DOM-exposed values (e.g. -webkit-font-size-delta from execCommand('FontSizeDelta')).
        ASSERT_NOT_REACHED();
        return nullptr;
    }
    switch (id) {
    case CSSPropertyID::CSSPropertyFirstTestDescriptorForFirstDescriptor:
        return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
    default:
        return nullptr;
    }
}

bool CSSPropertyParsing::isKeywordValidForFirstAtRuleDescriptor(CSSPropertyID, CSSValueID, const CSSParserContext&)
{
    return false;
}

bool CSSPropertyParsing::isKeywordFastPathEligibleFirstAtRuleDescriptor(CSSPropertyID)
{
    return false;
}

RefPtr<CSSValue> CSSPropertyParsing::parseSecondAtRuleDescriptor(CSSParserTokenRange& range, CSSPropertyID id, const CSSParserContext& context)
{
    if (!isExposed(id, context.propertySettings) && !isInternal(id)) {
        // Allow internal properties as we use them to parse several internal-only-shorthands (e.g. background-repeat),
        // and to handle certain DOM-exposed values (e.g. -webkit-font-size-delta from execCommand('FontSizeDelta')).
        ASSERT_NOT_REACHED();
        return nullptr;
    }
    switch (id) {
    case CSSPropertyID::CSSPropertyFirstTestDescriptorForSecondDescriptor:
        return CSSPrimitiveValueResolver<CSS::Number<>>::consumeAndResolve(range, context, { .parserMode = context.mode });
    default:
        return nullptr;
    }
}

bool CSSPropertyParsing::isKeywordValidForSecondAtRuleDescriptor(CSSPropertyID, CSSValueID, const CSSParserContext&)
{
    return false;
}

bool CSSPropertyParsing::isKeywordFastPathEligibleSecondAtRuleDescriptor(CSSPropertyID)
{
    return false;
}

} // namespace WebCore

